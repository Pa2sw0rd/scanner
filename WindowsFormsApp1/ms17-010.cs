using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;


namespace MS17010Test
{
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct SmbHeader
    {
        public UInt32 server_component;
        public byte smb_command;
        public byte error_class;
        public byte reserved1;
        public UInt16 error_code;
        public byte flags;
        public UInt16 flags2;
        public UInt16 process_id_high;
        public UInt64 signature;
        public UInt16 reserved2;
        public UInt16 tree_id;
        public UInt16 process_id;
        public UInt16 user_id;
        public UInt16 multiplex_id;
    }
}



namespace MS17010Test
{
    using System;


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class strings
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal strings()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if (object.ReferenceEquals(resourceMan, null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("MS17010Test.strings", typeof(strings).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Test Me.
        /// </summary>
        public static string buttonTestMe
        {
            get
            {
                return ResourceManager.GetString("buttonTestMe", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Test Other IP.
        /// </summary>
        public static string buttonTestOtherIP
        {
            get
            {
                return ResourceManager.GetString("buttonTestOtherIP", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to There was an execution error. This may mean it is not vulnerable, but the results are not reliable..
        /// </summary>
        public static string executionError
        {
            get
            {
                return ResourceManager.GetString("executionError", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to No.
        /// </summary>
        public static string no
        {
            get
            {
                return ResourceManager.GetString("no", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to That application is for checking if your computer is vulnerable to the flaw MS17-010 that the Ransonware WannaCry exploits.
        ///The first versions of that ransomware exploits that flaw to be able to spread over network using the protocol SMB.
        ///
        ///Worth note that this application only verifies if your computer is vulnerable to this flaw, and does not guarante that new versions of the ransomware wouldn&apos;t exploit other flaws on the system.
        ///
        ///For better test execute this application in another machine and execute wit [rest of string was truncated]&quot;;.
        /// </summary>
        public static string notice
        {
            get
            {
                return ResourceManager.GetString("notice", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Please wait ....
        /// </summary>
        public static string pleaseWait
        {
            get
            {
                return ResourceManager.GetString("pleaseWait", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Result.
        /// </summary>
        public static string result
        {
            get
            {
                return ResourceManager.GetString("result", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to There was an error checking the machine: {0}.
        /// </summary>
        public static string resultErrorMessage
        {
            get
            {
                return ResourceManager.GetString("resultErrorMessage", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to OS: {0}
        ///Build: {1}
        ///Workgroup: {2}
        ///Is Vulnerable: {3}
        ///Message {4}.
        /// </summary>
        public static string resultString
        {
            get
            {
                return ResourceManager.GetString("resultString", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Unknown.
        /// </summary>
        public static string unknown
        {
            get
            {
                return ResourceManager.GetString("unknown", resourceCulture);
            }
        }

        /// <summary>
        ///   Looks up a localized string similar to Yes.
        /// </summary>
        public static string yes
        {
            get
            {
                return ResourceManager.GetString("yes", resourceCulture);
            }
        }
    }
}


namespace MS17010Test
{
    public static class Constants
    {
        public static byte[] negotiateProtoRequest()
        {
            byte[] netbios = new byte[] { 0x00, 0x00, 0x00, 0x54 };
            byte[] smbHeader = new byte[] {
        0xFF, 0x53, 0x4D, 0x42,
        0x72,
        0x00, 0x00, 0x00, 0x00,
        0x18,
        0x01, 0x28,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0x00, 0x00,
        0x2F, 0x4B,
        0x00, 0x00,
        0xC5, 0x5E
      };

            byte[] negotiateProtoRequest = new byte[] {
        0x00,
        0x31, 0x00,
        0x02,
        0x4C, 0x41, 0x4E, 0x4D, 0x41, 0x4E, 0x31, 0x2E, 0x30, 0x00,
        0x02,
        0x4C, 0x4D, 0x31, 0x2E, 0x32, 0x58, 0x30, 0x30, 0x32, 0x00,
        0x02,
        0x4E, 0x54, 0x20, 0x4C, 0x41, 0x4E, 0x4D, 0x41, 0x4E, 0x20, 0x31, 0x2E, 0x30, 0x00,
        0x02,
        0x4E, 0x54, 0x20, 0x4C, 0x4D, 0x20, 0x30, 0x2E, 0x31, 0x32, 0x00
      };

            return netbios.Concat(smbHeader).Concat(negotiateProtoRequest).ToArray();
        }

        public static byte[] sessionSetupAndxRequest()
        {
            byte[] netbios = new byte[] { 0x00, 0x00, 0x00, 0x63 };
            byte[] smbHeader = new byte[] {
        0xFF, 0x53, 0x4D, 0x42,
        0x73,
        0x00, 0x00, 0x00, 0x00,
        0x18,
        0x01, 0x20,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0x00, 0x00,
        0x2F, 0x4B,
        0x00, 0x00,
        0xC5, 0x5E
      };

            byte[] setupAndxRequest = new byte[] {
        0x0D,
        0xFF,
        0x00,
        0x00, 0x00,
        0xDF, 0xFF,
        0x02, 0x00,
        0x01, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00,
        0x26, 0x00,
        0x00,
        0x2e, 0x00,
        0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x32, 0x30, 0x30, 0x30, 0x20, 0x32, 0x31, 0x39, 0x35, 0x00,
        0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x32, 0x30, 0x30, 0x30, 0x20, 0x35, 0x2e, 0x30, 0x00,
      };

            return netbios.Concat(smbHeader).Concat(setupAndxRequest).ToArray();
        }

        public static byte[] treeConnectAndxRequest(string ip, UInt16 userid)
        {
            byte[] userIdB = BitConverter.GetBytes(userid);
            byte[] netbios = new byte[] { 0x00, 0x00, 0x00, 0x47 };
            byte[] smbHeader = new byte[] {
        0xFF, 0x53, 0x4D, 0x42,
        0x75,
        0x00, 0x00, 0x00, 0x00,
        0x18,
        0x01, 0x20,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0x00, 0x00,
        0x2F, 0x4B,
        userIdB[0], userIdB[1],
        0xC5, 0x5E
      };

            byte[] treeConnectAndxRequest = new byte[] {
        0x04,
        0xFF,
        0x00,
        0x00, 0x00,
        0x00, 0x00,
        0x01, 0x00,
        0x1C, 0x00,
        0x00,
      };

            treeConnectAndxRequest = treeConnectAndxRequest.Concat(Encoding.ASCII.GetBytes($"\\\\{ip}\\IPC$"))
              .Concat(new byte[] { 0x00, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x00 }).ToArray();

            int length = smbHeader.Length + treeConnectAndxRequest.Length;
            netbios[3] = (byte)(length & 0xFF);
            netbios[2] = (byte)((length >> 8) & 0xFF);
            netbios[1] = (byte)((length >> 16) & 0xFF);

            return netbios.Concat(smbHeader).Concat(treeConnectAndxRequest).ToArray();
        }

        public static byte[] peeknamedpipeRequest(UInt16 treeid, UInt16 processid, UInt16 userid, UInt16 multiplex_id)
        {
            byte[] netbios = new byte[] {
        0x00,
        0x00, 0x00, 0x4a
      };

            byte[] treeIdB = BitConverter.GetBytes(treeid);
            byte[] processidB = BitConverter.GetBytes(processid);
            byte[] useridB = BitConverter.GetBytes(userid);
            byte[] multiplexidB = BitConverter.GetBytes(multiplex_id);

            byte[] smbHeader = new byte[] {
        0xFF, 0x53, 0x4D, 0x42,
        0x25,
        0x00, 0x00, 0x00, 0x00,
        0x18,
        0x01, 0x28,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        treeIdB[0], treeIdB[1],
        processidB[0], processidB[1],
        useridB[0], useridB[1],
        multiplexidB[0], multiplexidB[1],
      };

            byte[] peeknamedpipeRequest = new byte[] {
        0x10,
        0x00, 0x00,
        0x00, 0x00,
        0xff, 0xff,
        0xff, 0xff,
        0x00,
        0x00,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        0x00, 0x00,
        0x4a, 0x00,
        0x00, 0x00,
        0x4a, 0x00,
        0x02,
        0x00,
        0x23, 0x00,
        0x00, 0x00,
        0x07, 0x00,
        0x5c, 0x50, 0x49, 0x50, 0x45, 0x5c, 0x00
      };

            return netbios.Concat(smbHeader).Concat(peeknamedpipeRequest).ToArray();
        }

        public static byte[] sessionSetupRequest(UInt16 treeid, UInt16 processid, UInt16 userid, UInt16 multiplex_id)
        {
            byte[] netbios = new byte[] {
        0x00,
        0x00, 0x00, 0x4f
      };

            byte[] smbHeader = new byte[] {
        0xFF, 0x53, 0x4D, 0x42,
        0x32,
        0x00, 0x00, 0x00, 0x00,
        0x18,
        0x07, 0xc0,
        0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
        (byte)(treeid & 0xFF), (byte)(treeid >> 8),
        (byte)(processid & 0xFF), (byte)(processid >> 8),
        (byte)(userid & 0xFF), (byte)(userid >> 8),
        (byte)(multiplex_id & 0xFF), (byte)(multiplex_id >> 8),
      };

            byte[] sessionSetupRequest = new byte[] {
        0x0f,
        0x0c, 0x00,
        0x00, 0x00,
        0x01, 0x00,
        0x00, 0x00,
        0x00,
        0x00,
        0x00, 0x00,
        0xa6, 0xd9, 0xa4, 0x00,
        0x00, 0x00,
        0x0c, 0x00,
        0x42, 0x00,
        0x00, 0x00,
        0x4e, 0x00,
        0x01,
        0x00,
        0x0e, 0x00,
        0x00, 0x00,
        0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
      };

            return netbios.Concat(smbHeader).Concat(sessionSetupRequest).ToArray();
        }

        public static SmbHeader ByteArrayToSmbHeader(byte[] bytes)
        {
            GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
            SmbHeader stuff = (SmbHeader)Marshal.PtrToStructure(handle.AddrOfPinnedObject(), typeof(SmbHeader));
            handle.Free();
            return stuff;
        }
    }
}


namespace MS17010Test
{
    public class TestResult
    {
        public bool IsVulnerable;
        public bool VulnerabilityOK;
        public bool hadError;
        public string error;
        public string OSName;
        public string OSBuild;
        public string Workgroup;

        public TestResult()
        {
            IsVulnerable = false;
            VulnerabilityOK = false;
            hadError = false;
            OSName = "unknown";
            OSBuild = "unknown";
            Workgroup = "unknown";
            error = "";
        }
    }
}



namespace MS17010Test
{
    public class Tester
    {
        const int bufferSize = 1024;
        const int timeout = 5000;
        public TestResult TestIP(string ip,int port=445)
        {
            TestResult res = new TestResult();
            try
            {
                byte[] buffer = new byte[bufferSize];

                Socket client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                client.ReceiveTimeout = timeout;
                client.SendTimeout = timeout;

                IPAddress ipAddress = IPAddress.Parse(ip);
                client.Connect(new IPEndPoint(ipAddress, port));

                var request = Constants.negotiateProtoRequest();
                client.Send(request);
                var receivedBytes = client.Receive(buffer, SocketFlags.Partial);
                Console.WriteLine($"Received bytes: {receivedBytes}");
                var oBuff = buffer.Take(receivedBytes).ToArray();

                // Do nothing?

                request = Constants.sessionSetupAndxRequest();
                client.Send(request);
                receivedBytes = client.Receive(buffer, SocketFlags.Partial);
                Console.WriteLine($"Received bytes: {receivedBytes}");
                oBuff = buffer.Take(receivedBytes).ToArray();

                var netbiosB = oBuff.Take(4).ToArray();
                var smbHeaderB = oBuff.Skip(4).Take(32).ToArray();
                var smb = Constants.ByteArrayToSmbHeader(smbHeaderB);

                var sessionSetupAndxResponse = oBuff.Skip(36).ToArray();
                var nativeOsB = sessionSetupAndxResponse.Skip(9).ToArray();
                var osData = Encoding.ASCII.GetString(nativeOsB).Split('\x00');

                res.OSName = osData[0];
                if (osData.Count() >= 3)
                {
                    res.OSBuild = osData[1];
                    res.Workgroup = osData[2];
                }

                Console.WriteLine($"OS: {osData[0]} - UserId: {smb.user_id}");

                request = Constants.treeConnectAndxRequest(ip, smb.user_id);
                client.Send(request);
                receivedBytes = client.Receive(buffer, SocketFlags.Partial);
                oBuff = buffer.Take(receivedBytes).ToArray();

                netbiosB = oBuff.Take(4).ToArray();
                smbHeaderB = oBuff.Skip(4).Take(32).ToArray();
                smb = Constants.ByteArrayToSmbHeader(smbHeaderB);

                request = Constants.peeknamedpipeRequest(smb.tree_id, smb.process_id, smb.user_id, smb.multiplex_id);
                client.Send(request);
                receivedBytes = client.Receive(buffer, SocketFlags.Partial);
                oBuff = buffer.Take(receivedBytes).ToArray();

                netbiosB = oBuff.Take(4).ToArray();
                smbHeaderB = oBuff.Skip(4).Take(32).ToArray();
                smb = Constants.ByteArrayToSmbHeader(smbHeaderB);

                // 0xC000 02 05 - STATUS_INSUFF_SERVER_RESOURCES - vulnerable
                // 0xC000 00 08 - STATUS_INVALID_HANDLE
                // 0xC000 00 22 - STATUS_ACCESS_DENIED
                res.IsVulnerable = (smb.error_class == 0x05 && smb.reserved1 == 0x02 && smb.error_code == 0xC000);
                res.VulnerabilityOK = (smb.error_class == 0x08 && smb.reserved1 == 0x00 && smb.error_code == 0xC000) ||
                  (smb.error_class == 0x22 && smb.reserved1 == 0x00 && smb.error_code == 0xC000);
                res.error = $"{smb.error_class:X2} {smb.reserved1:X2} {smb.error_code:X4}";
                client.Close();
                return res;
            }
            catch (SocketException e)
            {
                if (e.SocketErrorCode == SocketError.ConnectionReset)
                {
                    res.IsVulnerable = false;
                    res.VulnerabilityOK = false;
                    res.hadError = true;
                    res.error = e.Message;
                    return res;
                }
                else
                {
                    throw e;
                }
            }
            return null;
        }

    }
}
